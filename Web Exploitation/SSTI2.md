## SSTI2
Author: Venax

Category: Web Exploitation

Difficulty: Medium

## Description
I made a cool website where you can announce whatever you want! I read about input sanitization, so now I remove any kind of characters that could be a problem :)

Additional details will be available after launching your challenge instance.

## Solve
**Flag:** `picoCTF{sst1_f1lt3r_byp4ss_a9824e27}`

- First I identified the template being used. It was `jinja2`.
- Now, since the description said that it removes any problematic characters, I used the common characters that were used in the payload for solving the SSTI1 challenge and verified one by one which were the invalid characters. It turned out that underscores(_) and dots(.) were invalid characters while the rest worked fine.
- So now, I again searched and found that underscores can be replaced using `\x5f` while we can use `|attr` to access the attributs instead of the dot notation. So using this new info, I modified the previous payload that was used to find the flag in SSTI1. But when I used it, it showed error.
- Now since everything matched with the original payload and I had only bypassed the invalid characters, I thought there might be some attribute missing in it. So as I searched around, I found that we need to include the `getitem` attribute as well to get the items from the dictionaries that are included in the payload when we use `|attr` to access the attributes. 
- So using this I made the final payload: `{{ request|attr('application')|attr('\x5f\x5fglobals\x5f\x5f')|attr('\x5f\x5fgetitem\x5f\x5f')('os')|attr('popen')('cat /challenge/flag')|attr('read')() }}`

   flag.

## Learnings
1. Filter Identification: We learned that simple tests (e.g., adfa_sfds $\rightarrow$ adfasfds) are crucial to pinpoint the exact filtered character (in this case, the underscore _).
2. The Underscore Problem: The filter prevented the use of all essential Python dunder methods (e.g., __globals__, __import__, __class__), effectively breaking all standard RCE chains.
3. The |attr() Bypass: We adopted the primary Jinja2 bypass technique: replacing Python's dot notation (.attribute) with the Jinja2 |attr('attribute') filter. This allowed us to access object attributes without using the . operator repeatedly.
4. The Hex Encoding Solution: Since the filter would likely strip underscores even from strings like '__globals__', we used hexadecimal encoding (\x5f) to represent the underscore. The payload was structured to deliver the dunder strings in a quote-enclosed, encoded format that the Jinja2 interpreter decodes correctly.
5. The Critical __getitem__ Attribute: We identified and fixed a key error in the RCE chain by correctly using the hex-encoded __getitem__ method. This method is essential for performing dictionary lookups (like accessing __import__ from the built-ins dictionary) when bracket notation (['key']) is not viable.

## References 
1. [Server side template injection with jinja2](https://onsecurity.io/article/server-side-template-injection-with-jinja2/)